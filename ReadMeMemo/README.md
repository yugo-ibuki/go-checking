## メモ

空の配列を作る時、以下のように数を指定する事がある。
```
arr := make([]Type, 0, len(t))
```

インスタンス化する方法
1. new()関数で作成(ゼロ値のみ)
```
p1 := new(Person)
```
2. var変数宣言(ゼロ値のみ)
```
var p2 Person
```
3. 複合リテラル(composite literal)で作成(初期値を設定できる)
```
p3 := &Person{
    FirstName: "苗字",
    LastName: "名前",
}
```

### 構造体を設計するポイント
1. ポインターとして扱うのか、値として扱うのか、両方を許可するのか
2. 値として扱える場合、イミュータブルなオブジェクトとするのか、ミュータブルなオブジェクトとするのか
3. 値として扱える場合に、ゼロ値での動作を補償するかどうか

#### ポインターとして扱う場合
内部にスライスやmap、ポインターなど参照方の要素を持っている場合には、基本的にポインター方でのみ扱う構造体にする。
構造体をコピーした時に、複数のインスタンスがこれらのフィールドのインスタンスを共有する事になる。

#### 値として扱う場合
インスタンス全体がコピーされる。
ポインターの場合とは違い、代入したり引数として渡すたびにコピーされる。
ポインターやmap、すたいすなどをその構造体のメンバーにできないため、わかりにくいバグを誘発する。
メリットとして、関数のライフサイクルでのみ消費される場合、スタックメモリ上にインスタンスが確保される。

#### イミュータブルなものとして扱う場合
イミュータブルな構造体では、変更を加えるメソッドがコピーを返すため、
必ず返り値を変数に入れたり他の関数に渡すなどができる。

どちらを使うかは設計者に委ねられるが
Goの場合、**エンティティと呼ばれるような構造体はミュータブルにするのが良い。**

### 実装方法を選択するポイント
・ポインターで扱うのを想定するか、値で扱うのを想定するか
・イミュータブルなAPIセットを用意するか、ミュータブルなAPIセットを用意するか
・ゼロ値の動作を保証するかどうか

### 空の構造体によって処理の開始を伝える
何かの処理の終了を待って、次の処理を開始するときなどに、何かが起きたことを伝える必要があり
この時に空の構造体のチャネルを作る。
空の構造体であれば、占有バイト数がゼロなので、消費メモリの削減になる。
